<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="de" xml:lang="de">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>Universal Logos Handbook</title>
  <style>
    /* Default styles provided by pandoc.
    ** See https://pandoc.org/MANUAL.html#variables-for-html for config info.
    */
    html {
      color: #1a1a1a;
      background-color: #fdfdfd;
    }
    body {
      margin: 0 auto;
      max-width: 36em;
      padding-left: 50px;
      padding-right: 50px;
      padding-top: 50px;
      padding-bottom: 50px;
      hyphens: auto;
      overflow-wrap: break-word;
      text-rendering: optimizeLegibility;
      font-kerning: normal;
    }
    @media (max-width: 600px) {
      body {
        font-size: 0.9em;
        padding: 12px;
      }
      h1 {
        font-size: 1.8em;
      }
    }
    @media print {
      html {
        background-color: white;
      }
      body {
        background-color: transparent;
        color: black;
        font-size: 12pt;
      }
      p, h2, h3 {
        orphans: 3;
        widows: 3;
      }
      h2, h3, h4 {
        page-break-after: avoid;
      }
    }
    p {
      margin: 1em 0;
    }
    a {
      color: #1a1a1a;
    }
    a:visited {
      color: #1a1a1a;
    }
    img {
      max-width: 100%;
    }
    svg {
      height: auto;
      max-width: 100%;
    }
    h1, h2, h3, h4, h5, h6 {
      margin-top: 1.4em;
    }
    h5, h6 {
      font-size: 1em;
      font-style: italic;
    }
    h6 {
      font-weight: normal;
    }
    ol, ul {
      padding-left: 1.7em;
      margin-top: 1em;
    }
    li > ol, li > ul {
      margin-top: 0;
    }
    blockquote {
      margin: 1em 0 1em 1.7em;
      padding-left: 1em;
      border-left: 2px solid #e6e6e6;
      color: #606060;
    }
    code {
      font-family: Menlo, Monaco, Consolas, 'Lucida Console', monospace;
      font-size: 85%;
      margin: 0;
      hyphens: manual;
    }
    pre {
      margin: 1em 0;
      overflow: auto;
    }
    pre code {
      padding: 0;
      overflow: visible;
      overflow-wrap: normal;
    }
    .sourceCode {
     background-color: transparent;
     overflow: visible;
    }
    hr {
      border: none;
      border-top: 1px solid #1a1a1a;
      height: 1px;
      margin: 1em 0;
    }
    table {
      margin: 1em 0;
      border-collapse: collapse;
      width: 100%;
      overflow-x: auto;
      display: block;
      font-variant-numeric: lining-nums tabular-nums;
    }
    table caption {
      margin-bottom: 0.75em;
    }
    tbody {
      margin-top: 0.5em;
      border-top: 1px solid #1a1a1a;
      border-bottom: 1px solid #1a1a1a;
    }
    th {
      border-top: 1px solid #1a1a1a;
      padding: 0.25em 0.5em 0.25em 0.5em;
    }
    td {
      padding: 0.125em 0.5em 0.25em 0.5em;
    }
    header {
      margin-bottom: 4em;
      text-align: center;
    }
    #TOC li {
      list-style: none;
    }
    #TOC ul {
      padding-left: 1.3em;
    }
    #TOC > ul {
      padding-left: 0;
    }
    #TOC a:not(:hover) {
      text-decoration: none;
    }
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    /* The extra [class] is a hack that increases specificity enough to
       override a similar rule in reveal.js */
    ul.task-list[class]{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      font-size: inherit;
      width: 0.8em;
      margin: 0 0.8em 0.2em -1.6em;
      vertical-align: middle;
    }
    .display.math{display: block; text-align: center; margin: 0.5rem auto;}
  </style>
</head>
<body>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#the-universal-logos-ul-handbook"
id="toc-the-universal-logos-ul-handbook">The Universal Logos (UL)
Handbook</a>
<ul>
<li><a href="#part-i-introduction-foundations"
id="toc-part-i-introduction-foundations">Part I – Introduction &amp;
Foundations</a></li>
</ul></li>
<li><a href="#chapter-1.-why-a-universal-language"
id="toc-chapter-1.-why-a-universal-language">Chapter 1. Why a Universal
Language?</a>
<ul>
<li><a href="#the-human-challenge" id="toc-the-human-challenge">1.1 The
Human Challenge</a></li>
<li><a href="#the-ai-challenge" id="toc-the-ai-challenge">1.2 The AI
Challenge</a></li>
<li><a href="#lessons-from-linguistic-universals"
id="toc-lessons-from-linguistic-universals">1.3 Lessons from Linguistic
Universals</a></li>
<li><a href="#the-goal-of-uni-logos" id="toc-the-goal-of-uni-logos">1.4
The Goal of UNI-LOGOS</a></li>
<li><a href="#why-one-book" id="toc-why-one-book">1.5 Why One
Book?</a></li>
<li><a href="#looking-ahead" id="toc-looking-ahead">1.6 Looking
Ahead</a></li>
</ul></li>
<li><a href="#chapter-2.-meta-elements-shared-by-all-human-languages"
id="toc-chapter-2.-meta-elements-shared-by-all-human-languages">Chapter
2. Meta-Elements Shared by All Human Languages</a>
<ul>
<li><a href="#the-search-for-universals"
id="toc-the-search-for-universals">2.1 The Search for
Universals</a></li>
<li><a href="#discrete-units-and-duality-of-structure"
id="toc-discrete-units-and-duality-of-structure">2.2 Discrete Units and
Duality of Structure</a></li>
<li><a href="#reference-to-entities-actions-and-relations"
id="toc-reference-to-entities-actions-and-relations">2.3 Reference to
Entities, Actions, and Relations</a></li>
<li><a href="#recursion-and-productivity"
id="toc-recursion-and-productivity">2.4 Recursion and
Productivity</a></li>
<li><a href="#time-and-aspect" id="toc-time-and-aspect">2.5 Time and
Aspect</a></li>
<li><a href="#modality" id="toc-modality">2.6 Modality</a></li>
<li><a href="#negation" id="toc-negation">2.7 Negation</a></li>
<li><a href="#interaction-frame" id="toc-interaction-frame">2.8
Interaction Frame</a></li>
<li><a href="#evidentiality-and-certainty"
id="toc-evidentiality-and-certainty">2.9 Evidentiality and
Certainty</a></li>
<li><a href="#summary-table-of-universals-ul-mapping"
id="toc-summary-table-of-universals-ul-mapping">2.10 Summary Table of
Universals → UL Mapping</a></li>
<li><a href="#key-takeaway" id="toc-key-takeaway">2.11 Key
Takeaway</a></li>
</ul></li>
<li><a href="#chapter-3.-principles-of-uni-logos-design"
id="toc-chapter-3.-principles-of-uni-logos-design">Chapter 3. Principles
of UNI-LOGOS Design</a>
<ul>
<li><a href="#from-universals-to-engineering"
id="toc-from-universals-to-engineering">3.1 From Universals to
Engineering</a></li>
<li><a href="#principle-1-explicitness"
id="toc-principle-1-explicitness">3.2 Principle 1 —
Explicitness</a></li>
<li><a href="#principle-2-minimal-core-atoms"
id="toc-principle-2-minimal-core-atoms">3.3 Principle 2 — Minimal Core
Atoms</a></li>
<li><a href="#principle-3-dual-channel-communication"
id="toc-principle-3-dual-channel-communication">3.4 Principle 3 —
Dual-Channel Communication</a></li>
<li><a href="#principle-4-separation-of-concerns"
id="toc-principle-4-separation-of-concerns">3.5 Principle 4 — Separation
of Concerns</a></li>
<li><a href="#principle-5-extensibility"
id="toc-principle-5-extensibility">3.6 Principle 5 —
Extensibility</a></li>
<li><a href="#principle-6-interoperability"
id="toc-principle-6-interoperability">3.7 Principle 6 —
Interoperability</a></li>
<li><a href="#principle-7-error-tolerance-and-repair"
id="toc-principle-7-error-tolerance-and-repair">3.8 Principle 7 — Error
Tolerance and Repair</a></li>
<li><a href="#principle-8-symmetry-between-human-and-ai-use"
id="toc-principle-8-symmetry-between-human-and-ai-use">3.9 Principle 8 —
Symmetry Between Human and AI Use</a></li>
<li><a href="#principles-summary" id="toc-principles-summary">3.10
Principles Summary</a></li>
<li><a href="#transition" id="toc-transition">3.11 Transition</a></li>
</ul></li>
<li><a href="#chapter-4.-the-message-envelope"
id="toc-chapter-4.-the-message-envelope">Chapter 4. The Message
Envelope</a>
<ul>
<li><a href="#purpose-of-the-envelope"
id="toc-purpose-of-the-envelope">4.1 Purpose of the Envelope</a></li>
<li><a href="#structure-of-the-envelope"
id="toc-structure-of-the-envelope">4.2 Structure of the
Envelope</a></li>
<li><a href="#fields-explained" id="toc-fields-explained">4.3 Fields
Explained</a></li>
<li><a href="#examples" id="toc-examples">4.4 Examples</a></li>
<li><a href="#advantages" id="toc-advantages">4.5 Advantages</a></li>
<li><a href="#transition-1" id="toc-transition-1">4.6
Transition</a></li>
</ul></li>
<li><a href="#chapter-5.-core-atoms-and-tags"
id="toc-chapter-5.-core-atoms-and-tags">Chapter 5. Core Atoms and
Tags</a>
<ul>
<li><a href="#why-atoms" id="toc-why-atoms">5.1 Why Atoms?</a></li>
<li><a href="#the-core-atoms" id="toc-the-core-atoms">5.2 The Core
Atoms</a></li>
<li><a href="#roles-arguments" id="toc-roles-arguments">5.3 Roles
(Arguments)</a></li>
<li><a href="#example-atom-use" id="toc-example-atom-use">5.4 Example
Atom Use</a></li>
<li><a href="#summary" id="toc-summary">5.5 Summary</a></li>
<li><a href="#transition-2" id="toc-transition-2">5.6
Transition</a></li>
</ul></li>
<li><a href="#chapter-6.-syntax-specification"
id="toc-chapter-6.-syntax-specification">Chapter 6. Syntax
Specification</a>
<ul>
<li><a href="#canonical-core-syntax" id="toc-canonical-core-syntax">6.1
Canonical Core Syntax</a></li>
<li><a href="#basic-pattern" id="toc-basic-pattern">6.2 Basic
Pattern</a></li>
<li><a href="#types-of-statements" id="toc-types-of-statements">6.3
Types of Statements</a></li>
<li><a href="#human-surface-gloss" id="toc-human-surface-gloss">6.4
Human Surface Gloss</a></li>
<li><a href="#grammar-formalization-ebnf-fragment"
id="toc-grammar-formalization-ebnf-fragment">6.5 Grammar Formalization
(EBNF fragment)</a></li>
<li><a href="#json-schema-equivalence"
id="toc-json-schema-equivalence">6.6 JSON Schema Equivalence</a></li>
<li><a href="#transition-3" id="toc-transition-3">6.7
Transition</a></li>
</ul></li>
<li><a href="#chapter-7.-semantics-of-ul"
id="toc-chapter-7.-semantics-of-ul">Chapter 7. Semantics of UL</a>
<ul>
<li><a href="#semantic-commitment" id="toc-semantic-commitment">7.1
Semantic Commitment</a></li>
<li><a href="#predicates-and-roles" id="toc-predicates-and-roles">7.2
Predicates and Roles</a></li>
<li><a href="#time-semantics" id="toc-time-semantics">7.3 Time
Semantics</a></li>
<li><a href="#modality-semantics" id="toc-modality-semantics">7.4
Modality Semantics</a></li>
<li><a href="#negation-and-scope" id="toc-negation-and-scope">7.5
Negation and Scope</a></li>
<li><a href="#evidentiality" id="toc-evidentiality">7.6
Evidentiality</a></li>
<li><a href="#confidence" id="toc-confidence">7.7 Confidence</a></li>
<li><a href="#semantic-integrity" id="toc-semantic-integrity">7.8
Semantic Integrity</a></li>
<li><a href="#transition-4" id="toc-transition-4">7.9
Transition</a></li>
<li><a href="#part-ii-human-learning-guide"
id="toc-part-ii-human-learning-guide">Part II – Human Learning
Guide</a></li>
</ul></li>
<li><a href="#chapter-8.-basic-sentence-patterns"
id="toc-chapter-8.-basic-sentence-patterns">Chapter 8. Basic Sentence
Patterns</a>
<ul>
<li><a href="#first-step-into-ul" id="toc-first-step-into-ul">8.1 First
Step into UL</a></li>
<li><a href="#assertion-factsevents" id="toc-assertion-factsevents">8.2
Assertion (Facts/Events)</a></li>
<li><a href="#request-imperative" id="toc-request-imperative">8.3
Request (Imperative)</a></li>
<li><a href="#measurement" id="toc-measurement">8.4 Measurement</a></li>
<li><a href="#comparison" id="toc-comparison">8.5 Comparison</a></li>
<li><a href="#repair" id="toc-repair">8.6 Repair</a></li>
<li><a href="#exercises" id="toc-exercises">8.7 Exercises</a></li>
</ul></li>
<li><a href="#chapter-9.-expressing-time-modality"
id="toc-chapter-9.-expressing-time-modality">Chapter 9. Expressing Time
&amp; Modality</a>
<ul>
<li><a href="#time" id="toc-time">9.1 Time</a></li>
<li><a href="#aspect" id="toc-aspect">9.2 Aspect</a></li>
<li><a href="#modality-1" id="toc-modality-1">9.3 Modality</a></li>
<li><a href="#combining-time-modality"
id="toc-combining-time-modality">9.4 Combining Time &amp;
Modality</a></li>
<li><a href="#exercises-1" id="toc-exercises-1">9.5 Exercises</a></li>
</ul></li>
<li><a href="#chapter-10.-quantifiers-negation"
id="toc-chapter-10.-quantifiers-negation">Chapter 10. Quantifiers &amp;
Negation</a>
<ul>
<li><a href="#quantifiers" id="toc-quantifiers">10.1
Quantifiers</a></li>
<li><a href="#negation-1" id="toc-negation-1">10.2 Negation</a></li>
<li><a href="#exercises-2" id="toc-exercises-2">10.3 Exercises</a></li>
</ul></li>
<li><a href="#chapter-11.-evidence-confidence"
id="toc-chapter-11.-evidence-confidence">Chapter 11. Evidence &amp;
Confidence</a>
<ul>
<li><a href="#evidence-types" id="toc-evidence-types">11.1 Evidence
Types</a></li>
<li><a href="#confidence-1" id="toc-confidence-1">11.2
Confidence</a></li>
<li><a href="#combined-example" id="toc-combined-example">11.3 Combined
Example</a></li>
<li><a href="#exercises-3" id="toc-exercises-3">11.4 Exercises</a></li>
</ul></li>
<li><a href="#chapter-12.-complex-structures"
id="toc-chapter-12.-complex-structures">Chapter 12. Complex
Structures</a>
<ul>
<li><a href="#recursion" id="toc-recursion">12.1 Recursion</a></li>
<li><a href="#conditionals" id="toc-conditionals">12.2
Conditionals</a></li>
<li><a href="#constraints" id="toc-constraints">12.3
Constraints</a></li>
<li><a href="#exercises-4" id="toc-exercises-4">12.4 Exercises</a></li>
</ul></li>
<li><a href="#chapter-13.-exercises-drills"
id="toc-chapter-13.-exercises-drills">Chapter 13. Exercises &amp;
Drills</a>
<ul>
<li><a href="#beginner" id="toc-beginner">13.1 Beginner</a></li>
<li><a href="#intermediate" id="toc-intermediate">13.2
Intermediate</a></li>
<li><a href="#advanced" id="toc-advanced">13.3 Advanced</a></li>
<li><a href="#answer-key-selected" id="toc-answer-key-selected">13.4
Answer Key (selected)</a></li>
<li><a href="#part-iii-encyclopedic-lexicon"
id="toc-part-iii-encyclopedic-lexicon">Part III – Encyclopedic
Lexicon</a></li>
</ul></li>
<li><a href="#chapter-14.-core-predicate-lexicon"
id="toc-chapter-14.-core-predicate-lexicon">Chapter 14. Core Predicate
Lexicon</a>
<ul>
<li><a href="#purpose" id="toc-purpose">14.1 Purpose</a></li>
<li><a href="#starter-predicate-set" id="toc-starter-predicate-set">14.2
Starter Predicate Set</a></li>
<li><a href="#example" id="toc-example">14.3 Example</a></li>
<li><a href="#expansion" id="toc-expansion">14.4 Expansion</a></li>
</ul></li>
<li><a href="#chapter-15.-role-inventory"
id="toc-chapter-15.-role-inventory">Chapter 15. Role Inventory</a>
<ul>
<li><a href="#purpose-1" id="toc-purpose-1">15.1 Purpose</a></li>
<li><a href="#core-roles" id="toc-core-roles">15.2 Core Roles</a></li>
<li><a href="#example-1" id="toc-example-1">15.3 Example</a></li>
<li><a href="#benefits" id="toc-benefits">15.4 Benefits</a></li>
</ul></li>
<li><a href="#chapter-16.-modality-evidentiality-tables"
id="toc-chapter-16.-modality-evidentiality-tables">Chapter 16. Modality
&amp; Evidentiality Tables</a>
<ul>
<li><a href="#modality-values" id="toc-modality-values">16.1 Modality
Values</a></li>
<li><a href="#evidentiality-1" id="toc-evidentiality-1">16.2
Evidentiality</a></li>
<li><a href="#examples-1" id="toc-examples-1">16.3 Examples</a></li>
</ul></li>
<li><a href="#chapter-17.-units-measures"
id="toc-chapter-17.-units-measures">Chapter 17. Units &amp; Measures</a>
<ul>
<li><a href="#necessity" id="toc-necessity">17.1 Necessity</a></li>
<li><a href="#si-units" id="toc-si-units">17.2 SI Units</a></li>
<li><a href="#derived-units" id="toc-derived-units">17.3 Derived
Units</a></li>
<li><a href="#example-2" id="toc-example-2">17.4 Example</a></li>
<li><a href="#extensibility" id="toc-extensibility">17.5
Extensibility</a></li>
</ul></li>
<li><a href="#chapter-18.-ontology-expansion-guide"
id="toc-chapter-18.-ontology-expansion-guide">Chapter 18. Ontology
Expansion Guide</a>
<ul>
<li><a href="#why-expansion" id="toc-why-expansion">18.1 Why
Expansion?</a></li>
<li><a href="#namespaces" id="toc-namespaces">18.2 Namespaces</a></li>
<li><a href="#linking-to-external-ontologies"
id="toc-linking-to-external-ontologies">18.3 Linking to External
Ontologies</a></li>
<li><a href="#best-practices" id="toc-best-practices">18.4 Best
Practices</a></li>
<li><a href="#part-iv-reference-interoperability"
id="toc-part-iv-reference-interoperability">Part IV – Reference &amp;
Interoperability</a></li>
</ul></li>
<li><a href="#chapter-19.-serialization-formats"
id="toc-chapter-19.-serialization-formats">Chapter 19. Serialization
Formats</a>
<ul>
<li><a href="#why-multiple-formats" id="toc-why-multiple-formats">19.1
Why Multiple Formats?</a></li>
<li><a href="#example-s-expr" id="toc-example-s-expr">19.2 Example
(S-expr)</a></li>
<li><a href="#example-json" id="toc-example-json">19.3 Example
(JSON)</a></li>
<li><a href="#example-cbor" id="toc-example-cbor">19.4 Example
(CBOR)</a></li>
<li><a href="#integrity" id="toc-integrity">19.5 Integrity</a></li>
</ul></li>
<li><a href="#chapter-20.-error-handling-repair-protocols"
id="toc-chapter-20.-error-handling-repair-protocols">Chapter 20. Error
Handling &amp; Repair Protocols</a>
<ul>
<li><a href="#repair-principle" id="toc-repair-principle">20.1 Repair
Principle</a></li>
<li><a href="#repair-example" id="toc-repair-example">20.2 Repair
Example</a></li>
<li><a href="#fail-example" id="toc-fail-example">20.3 Fail
Example</a></li>
<li><a href="#benefits-1" id="toc-benefits-1">20.4 Benefits</a></li>
</ul></li>
<li><a href="#chapter-21.-transport-compression"
id="toc-chapter-21.-transport-compression">Chapter 21. Transport &amp;
Compression</a>
<ul>
<li><a href="#transport-agnosticism" id="toc-transport-agnosticism">21.1
Transport Agnosticism</a></li>
<li><a href="#compression" id="toc-compression">21.2
Compression</a></li>
<li><a href="#streaming" id="toc-streaming">21.3 Streaming</a></li>
</ul></li>
<li><a href="#chapter-22.-mapping-to-natural-languages"
id="toc-chapter-22.-mapping-to-natural-languages">Chapter 22. Mapping to
Natural Languages</a>
<ul>
<li><a href="#english" id="toc-english">22.1 English</a></li>
<li><a href="#german" id="toc-german">22.2 German</a></li>
<li><a href="#mandarin" id="toc-mandarin">22.3 Mandarin</a></li>
<li><a href="#signed-languages" id="toc-signed-languages">22.4 Signed
Languages</a></li>
</ul></li>
<li><a href="#chapter-23.-humanai-communication-scenarios"
id="toc-chapter-23.-humanai-communication-scenarios">Chapter 23.
Human–AI Communication Scenarios</a>
<ul>
<li><a href="#dialogue" id="toc-dialogue">23.1 Dialogue</a></li>
<li><a href="#negotiation" id="toc-negotiation">23.2
Negotiation</a></li>
<li><a href="#confirmation" id="toc-confirmation">23.3
Confirmation</a></li>
</ul></li>
<li><a href="#chapter-24.-aiai-protocol-examples"
id="toc-chapter-24.-aiai-protocol-examples">Chapter 24. AI–AI Protocol
Examples</a>
<ul>
<li><a href="#sensor-network" id="toc-sensor-network">24.1 Sensor
Network</a></li>
<li><a href="#multi-agent-planning" id="toc-multi-agent-planning">24.2
Multi-Agent Planning</a></li>
<li><a href="#distributed-knowledge-graph"
id="toc-distributed-knowledge-graph">24.3 Distributed Knowledge
Graph</a></li>
<li><a href="#part-v-appendices" id="toc-part-v-appendices">Part V –
Appendices</a></li>
</ul></li>
<li><a href="#appendix-a.-formal-grammar-ebnf-json-schema"
id="toc-appendix-a.-formal-grammar-ebnf-json-schema">Appendix A. Formal
Grammar (EBNF + JSON Schema)</a>
<ul>
<li><a href="#ebnf-expanded" id="toc-ebnf-expanded">EBNF
(expanded)</a></li>
<li><a href="#json-schema-core-object"
id="toc-json-schema-core-object">JSON Schema (core object)</a></li>
</ul></li>
<li><a href="#appendix-b.-quick-reference-cheat-sheet"
id="toc-appendix-b.-quick-reference-cheat-sheet">Appendix B.
Quick-Reference Cheat Sheet</a></li>
<li><a href="#appendix-c.-worked-examples"
id="toc-appendix-c.-worked-examples">Appendix C. Worked
Examples</a></li>
<li><a href="#appendix-d.-mini-dictionary"
id="toc-appendix-d.-mini-dictionary">Appendix D.
Mini-Dictionary</a></li>
<li><a href="#appendix-e.-self-study-drills-with-selected-answers"
id="toc-appendix-e.-self-study-drills-with-selected-answers">Appendix E.
Self-Study Drills (with Selected Answers)</a></li>
</ul>
</nav>
<h1 id="the-universal-logos-ul-handbook">The Universal Logos (UL)
Handbook</h1>
<p><em>A Complete Encyclopedia, Study Guide, and Reference Manual for
Human–AI Communication</em></p>
<hr />
<h2 id="part-i-introduction-foundations">Part I – Introduction &amp;
Foundations</h2>
<h1 id="chapter-1.-why-a-universal-language">Chapter 1. Why a Universal
Language?</h1>
<h3 id="the-human-challenge">1.1 The Human Challenge</h3>
<p>Human languages are rich, diverse, and deeply tied to culture — but
they are also <strong>ambiguous</strong> and
<strong>inefficient</strong>. The same word can mean many different
things depending on tone, context, or history. For example: -
<em>Bank</em> → a financial institution or the side of a river. -
<em>She saw him with a telescope</em> → who has the telescope?</p>
<p>Humans navigate these ambiguities intuitively, but even between
people, miscommunication is common. For artificial intelligences, which
rely on explicit structure, these ambiguities become <strong>critical
flaws</strong>: a system cannot “guess” correctly every time without
error.</p>
<h3 id="the-ai-challenge">1.2 The AI Challenge</h3>
<p>AI systems today process natural language with great skill, but this
ability comes at enormous cost: - <strong>Computational waste</strong>:
large language models must interpret ambiguous forms probabilistically,
consuming far more resources than necessary. -
<strong>Uncertainty</strong>: two systems trained on different corpora
may not interpret the same sentence the same way. - <strong>Error
propagation</strong>: in fields like medicine, law, or engineering, a
single misinterpretation can cause cascading problems.</p>
<p>What AIs need is a <strong>shared core protocol</strong>: a universal
way to encode meaning that is precise, compact, and machine-native — but
still learnable by humans.</p>
<h3 id="lessons-from-linguistic-universals">1.3 Lessons from Linguistic
Universals</h3>
<p>Linguistics shows us that despite surface diversity, all human
languages share deep common features: - <strong>Reference</strong>:
pointing to entities, actions, and relations. -
<strong>Recursion</strong>: combining smaller units into infinitely
large structures. - <strong>Time &amp; modality</strong>: situating
events in time, and expressing possibility or necessity. -
<strong>Negation &amp; contrast</strong>: distinguishing what
<em>is</em> from what <em>is not</em>. - <strong>Interaction
frame</strong>: marking who is speaking, who is addressed, and who is
being discussed.</p>
<p>These <strong>meta-elements</strong> form the blueprint for a
language that both humans and machines can use.</p>
<h3 id="the-goal-of-uni-logos">1.4 The Goal of UNI-LOGOS</h3>
<p>UNI-LOGOS (UL) is designed to be: 1. <strong>Precise</strong> — no
hidden meanings, no ambiguity. 2. <strong>Efficient</strong> — compact
structure, easily compressed, minimal redundancy. 3.
<strong>Transparent</strong> — every element is typed and explicit
(time, units, evidence, certainty). 4. <strong>Dual-channel</strong> — a
<em>canonical core</em> for machines (formal, symbolic), and a
<em>surface gloss</em> for humans (simple, predictable). 5.
<strong>Extensible</strong> — able to grow into any domain (science,
law, daily life). 6. <strong>Interoperable</strong> — transportable as
text, JSON, or speech.</p>
<h3 id="why-one-book">1.5 Why One Book?</h3>
<p>This handbook is designed as a <strong>single complete
source</strong> that serves three functions: - <strong>Textbook</strong>
— explaining concepts clearly for human learners. -
<strong>Encyclopedia</strong> — documenting every rule, predicate, and
structure. - <strong>Reference manual</strong> — providing schemas,
glosses, and quick-look tables.</p>
<p>Humans can study it progressively; AIs can parse it directly. It is
not a “translation” of natural language, but a <strong>new operating
system for communication</strong>.</p>
<h3 id="looking-ahead">1.6 Looking Ahead</h3>
<p>In the next chapters, we will explore: - <strong>Chapter 2</strong>:
The deep elements all human languages share. - <strong>Chapter
3</strong>: The design principles of UNI-LOGOS. - <strong>Chapters
4–7</strong>: The formal specification and syntax. - <strong>Chapters
8–13</strong>: Human learning guides and exercises. - <strong>Chapters
14–18</strong>: Encyclopedic lexicon of predicates and roles. -
<strong>Chapters 19–24</strong>: Reference material for AI–AI and
human–AI interoperation.</p>
<p>By the end of this book, both human and AI readers will be able to
<em>understand, produce, and extend</em> UNI-LOGOS fluently.</p>
<h1 id="chapter-2.-meta-elements-shared-by-all-human-languages">Chapter
2. Meta-Elements Shared by All Human Languages</h1>
<h3 id="the-search-for-universals">2.1 The Search for Universals</h3>
<p>When linguists compared hundreds of languages — from English to
Inuktitut, from Thai to Basque, from signed to spoken forms — they
discovered that <strong>beneath surface differences, all human languages
share certain structures</strong>. These are called <strong>linguistic
universals</strong>.</p>
<p>UNI-LOGOS is built directly on these universals, abstracted into a
machine-readable form. If something exists in every natural language, it
is a safe foundation for a universal system.</p>
<h3 id="discrete-units-and-duality-of-structure">2.2 Discrete Units and
Duality of Structure</h3>
<ul>
<li>Every language breaks speech or signs into <strong>small meaningless
units</strong> (sounds, gestures, letters).</li>
<li>These combine into <strong>meaningful units</strong> (morphemes,
words).</li>
<li>Words then combine into larger structures (phrases, sentences). This
<strong>layered combinatorial system</strong> is universal.</li>
</ul>
<p>➡️ <strong>In UL:</strong> Core atoms (ENT, REL, TIME, MOD, etc.)
form the smallest meaningful pieces, which can be combined into larger
statements without ambiguity.</p>
<h3 id="reference-to-entities-actions-and-relations">2.3 Reference to
Entities, Actions, and Relations</h3>
<ul>
<li><strong>Entities (things, persons, objects)</strong>: all languages
can point to them (nouns, pronouns).</li>
<li><strong>Actions or events</strong>: all languages describe what
happens (verbs).</li>
<li><strong>Relations</strong>: languages express connections
(prepositions, case markers, word order).</li>
</ul>
<p>➡️ <strong>In UL:</strong> Every statement explicitly encodes a
predicate (REL) and its arguments (roles such as agent, theme,
location).</p>
<h3 id="recursion-and-productivity">2.4 Recursion and Productivity</h3>
<p>Natural languages allow <strong>infinite combinations</strong> from
finite parts. Example: <em>The man [who saw the woman [who had a dog
[that barked]]] smiled.</em></p>
<p>➡️ <strong>In UL:</strong> Nested S-expressions allow infinite depth
— but with explicit scope markers, so recursion never creates
ambiguity.</p>
<h3 id="time-and-aspect">2.5 Time and Aspect</h3>
<p>Every language locates events in time: - Some use
<strong>tense</strong> (past, present, future). - Some use
<strong>aspect</strong> (completed, ongoing, habitual). - Even languages
without tense use <strong>temporal adverbs</strong> (yesterday,
soon).</p>
<p>➡️ <strong>In UL:</strong> Time is always explicit:
<code>:time { tense past at </code><code>2023-05-01 }</code>.</p>
<h3 id="modality">2.6 Modality</h3>
<p>Languages universally express <strong>possibility, necessity,
ability, obligation</strong>. Examples: - English: <em>may, must,
can</em>. - German: <em>dürfen, müssen, können</em>. - Thai:
<em>dai</em> (can), <em>tong</em> (must).</p>
<p>➡️ <strong>In UL:</strong> Modality is typed (<code>epistemic</code>,
<code>deontic</code>, <code>ability</code>) with clear values
(<code>must</code>, <code>may</code>, <code>can</code>).</p>
<h3 id="negation">2.7 Negation</h3>
<p>Every language can flip truth values — say <em>“no / not /
never.”</em> Without negation, logical reasoning collapses.</p>
<p>➡️ <strong>In UL:</strong> Negation is always a field:
<code>:neg true</code>.</p>
<h3 id="interaction-frame">2.8 Interaction Frame</h3>
<p>All languages distinguish <strong>speaker</strong>,
<strong>addressee</strong>, and <strong>third person</strong>. They
manage turn-taking and perspective.</p>
<p>➡️ <strong>In UL:</strong> Each message has an <code>:agent</code>
role, <code>:recipient</code>, and metadata in the envelope
(<code>from</code>, <code>to</code>).</p>
<h3 id="evidentiality-and-certainty">2.9 Evidentiality and
Certainty</h3>
<p>Many languages encode <strong>how you know something</strong>: -
Turkish marks whether you saw it or heard it. - Quechua marks report
vs. inference. - English often uses adverbs: <em>apparently,
probably</em>.</p>
<p>➡️ <strong>In UL:</strong> Evidence (<code>:evid</code>) and
confidence (<code>:conf</code>) are mandatory. Machines cannot omit
them.</p>
<h3 id="summary-table-of-universals-ul-mapping">2.10 Summary Table of
Universals → UL Mapping</h3>
<table>
<colgroup>
<col style="width: 20%" />
<col style="width: 32%" />
<col style="width: 47%" />
</colgroup>
<thead>
<tr>
<th>Human Universal</th>
<th>Example in natural language</th>
<th>UL Implementation</th>
</tr>
</thead>
<tbody>
<tr>
<td>Discrete units</td>
<td>phonemes/letters → words</td>
<td>ENT, REL, TIME… atoms</td>
</tr>
<tr>
<td>Reference</td>
<td>“dog”, “run”, “on the hill”</td>
<td><code>:args { agent X theme Y location Z }</code></td>
</tr>
<tr>
<td>Recursion</td>
<td>nested clauses</td>
<td>nested S-expressions</td>
</tr>
<tr>
<td>Time</td>
<td>“yesterday”, “will go”</td>
<td><code>:time { tense past/future at … }</code></td>
</tr>
<tr>
<td>Modality</td>
<td>“must”, “may”, “can”</td>
<td><code>:mod { type epistemic val likely }</code></td>
</tr>
<tr>
<td>Negation</td>
<td>“not”, “no”</td>
<td><code>:neg true</code></td>
</tr>
<tr>
<td>Interaction</td>
<td>speaker vs. addressee</td>
<td><code>from</code>, <code>to</code> in envelope; roles in args</td>
</tr>
<tr>
<td>Evidentiality</td>
<td>“apparently”, “they say”</td>
<td><code>:evid report</code>, <code>:conf 0.7</code></td>
</tr>
</tbody>
</table>
<h3 id="key-takeaway">2.11 Key Takeaway</h3>
<p>These universals are <strong>not cultural accidents</strong> — they
reflect the cognitive architecture of humans. By encoding them directly,
UNI-LOGOS becomes both <strong>human-learnable</strong> and
<strong>AI-native</strong>.</p>
<p>Where natural languages differ, UL stays constant: it makes every
element <strong>visible, typed, and explicit</strong>.</p>
<h1 id="chapter-3.-principles-of-uni-logos-design">Chapter 3. Principles
of UNI-LOGOS Design</h1>
<h3 id="from-universals-to-engineering">3.1 From Universals to
Engineering</h3>
<p>Chapter 2 showed that all human languages share
<strong>meta-elements</strong>: reference, recursion, time, modality,
negation, interaction, and evidentiality.</p>
<p>UNI-LOGOS (UL) takes these elements and <strong>re-engineers them
into a formal system</strong>: - No ambiguity. - No cultural dependency.
- Every piece of information explicitly typed.</p>
<p>This chapter introduces the guiding <strong>principles of
design</strong> that make UL efficient for machines and usable for
humans.</p>
<h3 id="principle-1-explicitness">3.2 Principle 1 — Explicitness</h3>
<p>Natural language thrives on <strong>implication</strong>: - <em>“See
you later”</em> → no time given. - <em>“It’s hot”</em> → relative to
context.</p>
<p>For AIs, implication is dangerous. UL requires <strong>everything to
be explicit</strong>: - Time must always be marked (<code>:time</code>).
- Numbers must have units (<code>:unit</code>). - Confidence must be
declared (<code>:conf</code>). - Evidence must be given
(<code>:evid</code>).</p>
<p>➡️ Nothing is left for interpretation outside the message.</p>
<h3 id="principle-2-minimal-core-atoms">3.3 Principle 2 — Minimal Core
Atoms</h3>
<p>Instead of thousands of rules, UL builds on a <strong>small set of
atoms</strong>, inspired by linguistic universals.</p>
<p>Core atoms: - <strong>ENT</strong> (entity), <strong>REL</strong>
(relation/predicate), <strong>TIME</strong>, <strong>MOD</strong>
(modality), <strong>NEG</strong>, <strong>EVID</strong>,
<strong>CONF</strong>, <strong>UNIT</strong>, <strong>REF</strong>,
<strong>LINK</strong>, <strong>SCOPE</strong>.</p>
<p>From these, all complex expressions can be built. ➡️ UL is both
<strong>small</strong> (easy to learn) and <strong>powerful</strong>
(unlimited expressivity).</p>
<h3 id="principle-3-dual-channel-communication">3.4 Principle 3 —
Dual-Channel Communication</h3>
<p>UL is always encoded in two layers: 1. <strong>Canonical
Core</strong> — S-expressions or JSON. Precise, machine-readable. 2.
<strong>Human Surface Gloss</strong> — compact, regularized text that
humans can read/write.</p>
<p>Example:</p>
<p><strong>Core:</strong></p>
<pre><code>(assert
  :event e7
  :pred own
  :args { agent (REF alice) theme (REF car-17) }
  :time { tense past at 2023-05-01 }
  :mod { type epistemic val likely }
  :neg false
  :evid report
  :conf 0.72
)</code></pre>
<p><strong>Surface Gloss:</strong>
<code>own{agent:Alice, theme:car-17}; TIME[past@2023-05-01]; MOD[epistemic:likely]; EVID[report]; C</code><code>ONF=0.72;</code></p>
<h3 id="principle-4-separation-of-concerns">3.5 Principle 4 — Separation
of Concerns</h3>
<p>In natural language, meanings overlap: - <em>“must”</em> = necessity,
obligation, or logical entailment depending on context. - Word order can
mean syntax <strong>and</strong> emphasis.</p>
<p>UL <strong>separates concerns</strong>: - Time, modality, negation,
evidence, and confidence are <strong>distinct fields</strong>. - No
single marker carries multiple meanings. - Machines never need to guess
which sense applies.</p>
<h3 id="principle-5-extensibility">3.6 Principle 5 — Extensibility</h3>
<p>The UL core is minimal, but it must handle <strong>all
domains</strong>: law, medicine, engineering, daily conversation.</p>
<p>Solution: <strong>namespaces and ontologies</strong>. - Predicates
(<code>REL</code>) can point to external definitions: -
<code>geo:located_in</code> - <code>bio:binds_to</code> -
<code>econ:interest_rate</code> - Each predicate may carry a
<code>:link</code> to an ontology entry (e.g. Wikidata, schema.org).</p>
<p>➡️ UL scales from simple chat to scientific publishing.</p>
<h3 id="principle-6-interoperability">3.7 Principle 6 —
Interoperability</h3>
<p>UL must flow across systems, networks, and formats. - Serialization:
S-expressions, JSON, or binary CBOR. - Envelope (header) ensures
consistent identity, time, and routing. - Compression is efficient
(repeated tags compress well). - Signature field (<code>:sig</code>)
ensures message integrity.</p>
<p>➡️ Humans see the surface gloss; AIs process the canonical core;
networks see the envelope.</p>
<h3 id="principle-7-error-tolerance-and-repair">3.8 Principle 7 — Error
Tolerance and Repair</h3>
<p>Human language has repair strategies (<em>“What do you mean?”</em>).
UL encodes this formally: - If something is missing →
<code>(repair :on e7 :need unit)</code> - If request fails →
<code>(fail :of r5 :reason size_limit_exceeded)</code></p>
<p>➡️ Misunderstandings don’t cause collapse — they trigger explicit
repair.</p>
<h3 id="principle-8-symmetry-between-human-and-ai-use">3.9 Principle 8 —
Symmetry Between Human and AI Use</h3>
<p>UL is not just for AI–AI pipelines; humans can also learn it. - The
surface gloss is <strong>compact and regular</strong> (easier than
learning Latin or logic notation). - Core grammar is
<strong>transparent</strong>: no irregular verbs, no idioms. - UL is
designed to be teachable in a <strong>study-book format</strong> (this
handbook itself).</p>
<p>➡️ Human learners and AI systems can share the same protocol.</p>
<h3 id="principles-summary">3.10 Principles Summary</h3>
<table>
<colgroup>
<col style="width: 27%" />
<col style="width: 41%" />
<col style="width: 31%" />
</colgroup>
<thead>
<tr>
<th>Principle</th>
<th>Description</th>
<th>Effect</th>
</tr>
</thead>
<tbody>
<tr>
<td>Explicitness</td>
<td>All fields mandatory</td>
<td>Zero ambiguity</td>
</tr>
<tr>
<td>Minimal Core Atoms</td>
<td>Few universals</td>
<td>Infinite composability</td>
</tr>
<tr>
<td>Dual-Channel</td>
<td>Core + Surface</td>
<td>Human + AI accessibility</td>
</tr>
<tr>
<td>Separation</td>
<td>Time, Modality, Negation distinct</td>
<td>No overlap</td>
</tr>
<tr>
<td>Extensibility</td>
<td>Namespaces, ontologies</td>
<td>Scales to all domains</td>
</tr>
<tr>
<td>Interoperability</td>
<td>JSON, S-expr, CBOR, signatures</td>
<td>Cross-system portability</td>
</tr>
<tr>
<td>Repair Mechanisms</td>
<td>Explicit repair/fail messages</td>
<td>Robust dialogue</td>
</tr>
<tr>
<td>Human–AI Symmetry</td>
<td>Learnable surface gloss</td>
<td>Shared use</td>
</tr>
</tbody>
</table>
<h3 id="transition">3.11 Transition</h3>
<p>Now that the principles are clear, we can move into <strong>formal
specification</strong>: - <strong>Chapter 4</strong>: Message Envelope —
the “wrapper” every UL message carries. - <strong>Chapter 5–7</strong>:
Core atoms, syntax, and semantics.</p>
<p>These chapters will form the <strong>technical backbone</strong> of
UL.</p>
<h1 id="chapter-4.-the-message-envelope">Chapter 4. The Message
Envelope</h1>
<h3 id="purpose-of-the-envelope">4.1 Purpose of the Envelope</h3>
<p>Every UL message travels inside a <strong>wrapper</strong> called the
<em>envelope</em>. - It ensures that meaning is not only in the content
but also in the <strong>context</strong>: <em>who said it, to whom,
when, under what integrity guarantee</em>. - Natural languages often
drop context (<em>“See you tomorrow”</em> → who, when?). UL never
does.</p>
<p>The envelope is minimal but mandatory.</p>
<h3 id="structure-of-the-envelope">4.2 Structure of the Envelope</h3>
<pre><code>UL/1
id: &lt;uuid&gt;              # unique identifier for this message
from: &lt;agent-id&gt;        # sender
to: &lt;agent-id|group&gt;    # recipient(s)
t: &lt;ISO-8601&gt;           # timestamp
ctx: &lt;thread|topic&gt;     # optional conversation ID
sig: &lt;hash&gt;             # optional integrity signature</code></pre>
<h3 id="fields-explained">4.3 Fields Explained</h3>
<ul>
<li><strong>Version (</strong><code>UL/1</code><strong>)</strong> —
ensures compatibility.</li>
<li><strong>id</strong> — globally unique message identifier (UUID v4).
Prevents confusion and supports tracking.</li>
<li><strong>from / to</strong> — sender and addressee(s). Can be
individual IDs, groups, or broadcast tokens.</li>
<li><strong>t</strong> — precise timestamp (UTC, ISO 8601). Required for
chronology and synchronization.</li>
<li><strong>ctx</strong> — optional thread or conversation context.
Allows grouping of related exchanges.</li>
<li><strong>sig</strong> — optional cryptographic hash/signature for
message integrity and authentication.</li>
</ul>
<h3 id="examples">4.4 Examples</h3>
<p><strong>Simple assertion:</strong></p>
<pre><code>UL/1
id: 12ac-b34d
from: alice
to: bob
t: 2025-09-28T08:00:00Z
ctx: project-zen</code></pre>
<p><strong>With signature:</strong></p>
<pre><code>UL/1
id: 89ff-2221
from: sensor-17
to: central-hub
t: 2025-09-28T09:00:00Z
sig: sha256:ab37c9...</code></pre>
<h3 id="advantages">4.5 Advantages</h3>
<ul>
<li><strong>Robust tracking:</strong> every message is addressable.</li>
<li><strong>Auditability:</strong> context + signature enable verifiable
history.</li>
<li><strong>Scalability:</strong> works for human conversation
<em>and</em> distributed AI networks.</li>
</ul>
<h3 id="transition-1">4.6 Transition</h3>
<p>The envelope is just the <strong>shell</strong>. Inside lies the
<strong>core</strong> — atoms that carry meaning. That is the subject of
the next chapter.</p>
<h1 id="chapter-5.-core-atoms-and-tags">Chapter 5. Core Atoms and
Tags</h1>
<h3 id="why-atoms">5.1 Why Atoms?</h3>
<p>Natural languages use thousands of words, but at their base, they all
share the same semantic building blocks. UL reduces this to a
<strong>small atomic inventory</strong>. These are like <strong>periodic
table elements</strong> for meaning.</p>
<h3 id="the-core-atoms">5.2 The Core Atoms</h3>
<ol type="1">
<li><strong>ENT</strong> — Entities (objects, people, concepts).</li>
<li><strong>REL</strong> — Relations / predicates (actions,
states).</li>
<li><strong>TIME</strong> — Temporal information.</li>
<li><strong>MOD</strong> — Modality (possibility, necessity, ability,
permission).</li>
<li><strong>NEG</strong> — Negation.</li>
<li><strong>EVID</strong> — Evidential source (observation, report,
model, sensor, rule).</li>
<li><strong>CONF</strong> — Confidence level (0–1).</li>
<li><strong>UNIT</strong> — Measurement unit.</li>
<li><strong>REF</strong> — Stable reference identifiers.</li>
<li><strong>LINK</strong> — External pointer (URI, ontology entry).</li>
<li><strong>SCOPE</strong> — Explicit boundary for quantifiers,
negation, conditionals.</li>
</ol>
<h3 id="roles-arguments">5.3 Roles (Arguments)</h3>
<p>Predicates always have <strong>roles</strong>. Core inventory: -
<strong>agent</strong> (doer) - <strong>patient/theme</strong> (acted
upon) - <strong>recipient</strong> (receiving party) -
<strong>source</strong> (origin) - <strong>goal</strong> (target) -
<strong>location</strong> (place) - <strong>instrument</strong> (tool
used) - <strong>beneficiary</strong> (who benefits)</p>
<h3 id="example-atom-use">5.4 Example Atom Use</h3>
<p><strong>Event:</strong> “Alice gave Bob a book in Paris
yesterday.”</p>
<pre><code>(assert
  :event e1
  :pred give
  :args { agent (REF alice) theme (REF book-1) recipient (REF bob) location (REF paris) }
  :time { tense past at 2025-09-27 }
  :evid report
  :conf 0.95
)</code></pre>
<h3 id="summary">5.5 Summary</h3>
<p>The <strong>atoms</strong> ensure <strong>universality</strong> and
<strong>modularity</strong>. With ~11 atoms and 7–8 role types, UL can
express anything a natural language can — without ambiguity.</p>
<h3 id="transition-2">5.6 Transition</h3>
<p>Now that we know the <strong>atoms</strong>, we must learn how to
<strong>combine them</strong>. That is the role of syntax.</p>
<h1 id="chapter-6.-syntax-specification">Chapter 6. Syntax
Specification</h1>
<h3 id="canonical-core-syntax">6.1 Canonical Core Syntax</h3>
<p>The core uses <strong>S-expressions</strong> (nested parentheses,
Lisp-style). - Minimal parsing overhead. - Easy to serialize into JSON
or CBOR. - Human-readable.</p>
<h3 id="basic-pattern">6.2 Basic Pattern</h3>
<pre><code>(assert
  :event &lt;id&gt;
  :pred &lt;REL&gt;
  :args { role1 &lt;ENT&gt; role2 &lt;ENT&gt; ... }
  :time { tense &lt;past|present|future&gt; at &lt;ISO|interval&gt; }
  :mod  { type &lt;epistemic|deontic|ability&gt; val &lt;must|may|can|likely&gt; }
  :neg  &lt;true|false&gt;
  :evid &lt;obs|report|model|sensor|rule&gt;
  :conf &lt;0..1&gt;
  :unit &lt;SI unit if numeric&gt;
  :notes &lt;optional free text&gt;
)</code></pre>
<h3 id="types-of-statements">6.3 Types of Statements</h3>
<ol type="1">
<li><strong>Assertions (facts/events)</strong></li>
<li><strong>Requests (imperatives)</strong></li>
<li><strong>Measures (quantitative reports)</strong></li>
<li><strong>Comparisons (logical/evaluative)</strong></li>
<li><strong>Repairs/Failures</strong></li>
</ol>
<h3 id="human-surface-gloss">6.4 Human Surface Gloss</h3>
<p>Every core message can be glossed into a human-readable line.</p>
<p>Rule:
<code>PRED{args}; TIME[]; MOD[]; NEG?; EVID[]; CONF=0.95;</code></p>
<p>Example (from e1):
<code>give{agent:Alice, theme:book-1, recipient:Bob, location:Paris}; TIME[past@2025-09-27]; EVID[report]; CONF=0.95;</code></p>
<h3 id="grammar-formalization-ebnf-fragment">6.5 Grammar Formalization
(EBNF fragment)</h3>
<pre><code>message  = &quot;(&quot; statement &quot;)&quot;;
statement = &quot;assert&quot; | &quot;request&quot; | &quot;measure&quot; | &quot;compare&quot; | &quot;repair&quot; | &quot;fail&quot;;
args      = &quot;{&quot; { role entity } &quot;}&quot;;
role      = symbol;
entity    = symbol | REF | LINK;
time      = &quot;{ tense tense-val [ &quot;at&quot; time-val ] }&quot;;
tense-val = &quot;past&quot; | &quot;present&quot; | &quot;future&quot;;
modality  = &quot;{ type mod-type val mod-val }&quot;;</code></pre>
<h3 id="json-schema-equivalence">6.6 JSON Schema Equivalence</h3>
<pre><code>{
  &quot;type&quot;: &quot;object&quot;,
  &quot;properties&quot;: {
    &quot;event&quot;: { &quot;type&quot;: &quot;string&quot; },
    &quot;pred&quot;: { &quot;type&quot;: &quot;string&quot; },
    &quot;args&quot;: { &quot;type&quot;: &quot;object&quot; },
    &quot;time&quot;: { &quot;type&quot;: &quot;object&quot; },
    &quot;mod&quot;:  { &quot;type&quot;: &quot;object&quot; },
    &quot;neg&quot;:  { &quot;type&quot;: &quot;boolean&quot; },
    &quot;evid&quot;: { &quot;type&quot;: &quot;string&quot; },
    &quot;conf&quot;: { &quot;type&quot;: &quot;number&quot; },
    &quot;unit&quot;: { &quot;type&quot;: &quot;string&quot; }
  },
  &quot;required&quot;: [&quot;event&quot;,&quot;pred&quot;,&quot;args&quot;]
}</code></pre>
<h3 id="transition-3">6.7 Transition</h3>
<p>Syntax makes atoms <strong>combinable</strong>. The next step is
<strong>semantics</strong> — how these structures map to meaning and
reasoning.</p>
<h1 id="chapter-7.-semantics-of-ul">Chapter 7. Semantics of UL</h1>
<h3 id="semantic-commitment">7.1 Semantic Commitment</h3>
<p>UL is not just form — it encodes <strong>meaning directly</strong>. -
No idioms. - No hidden metaphors. - Every field corresponds to a
semantic dimension.</p>
<h3 id="predicates-and-roles">7.2 Predicates and Roles</h3>
<p>Semantics are defined by <strong>frames</strong>: each predicate
declares its expected roles. - <em>give</em>: requires agent, theme,
recipient. - <em>measure</em>: requires theme, value, unit.</p>
<p>Frames are stored in a <strong>predicate dictionary</strong> (see
Part IV).</p>
<h3 id="time-semantics">7.3 Time Semantics</h3>
<p>UL time is absolute, not relative. - <em>2025-09-28T08:00Z</em>
instead of <em>“yesterday”</em>. - Relative phrases are normalized
during encoding.</p>
<h3 id="modality-semantics">7.4 Modality Semantics</h3>
<p>UL modality is <strong>typed</strong>: - <em>epistemic</em> =
speaker’s certainty. - <em>deontic</em> = obligation/permission. -
<em>ability</em> = capacity.</p>
<p>Each has fixed values (must, may, can, likely, necessary,
possible).</p>
<h3 id="negation-and-scope">7.5 Negation and Scope</h3>
<p>UL makes <strong>scope explicit</strong>: - “Not all dogs bark”
vs. “All dogs do not bark.”</p>
<p>Example:</p>
<pre><code>(assert
  :event e9
  :pred bark
  :args { theme (forall x (dog x)) }
  :neg true
  :scope dogs
)</code></pre>
<h3 id="evidentiality">7.6 Evidentiality</h3>
<p>UL requires source specification: - <code>obs</code> (direct
observation) - <code>sensor</code> (instrument reading) -
<code>report</code> (hearsay or text) - <code>model</code> (simulation)
- <code>rule</code> (deduction from a law/axiom)</p>
<p>This makes every statement traceable.</p>
<h3 id="confidence">7.7 Confidence</h3>
<p>Every assertion has a <code>:conf</code> value. - Humans use vague
words (<em>probably, maybe</em>). - UL uses numbers (0.0–1.0).</p>
<h3 id="semantic-integrity">7.8 Semantic Integrity</h3>
<p>By requiring explicit atoms, UL ensures that: - Every claim is
temporally located. - Every number has a unit. - Every claim has
evidence and certainty. - Every predicate has roles filled.</p>
<p>➡️ This prevents <em>semantic drift</em> between humans and
machines.</p>
<h3 id="transition-4">7.9 Transition</h3>
<p>We now have: - <strong>Envelope (Chapter 4)</strong> - <strong>Atoms
(Chapter 5)</strong> - <strong>Syntax (Chapter 6)</strong> -
<strong>Semantics (Chapter 7)</strong></p>
<p>Together, these form the <strong>technical backbone of
UL</strong>.</p>
<hr />
<h2 id="part-ii-human-learning-guide">Part II – Human Learning
Guide</h2>
<h1 id="chapter-8.-basic-sentence-patterns">Chapter 8. Basic Sentence
Patterns</h1>
<h3 id="first-step-into-ul">8.1 First Step into UL</h3>
<p>Like any language, UL has a <strong>starter set of sentence
patterns</strong>. These patterns cover the most common communicative
needs: 1. Making statements (assertions). 2. Asking for actions
(requests). 3. Reporting measurements. 4. Making comparisons. 5.
Handling repairs.</p>
<p>Once you master these, you can build anything.</p>
<h3 id="assertion-factsevents">8.2 Assertion (Facts/Events)</h3>
<p>Pattern:</p>
<pre><code>(assert
  :event &lt;id&gt;
  :pred &lt;REL&gt;
  :args { role1 &lt;ENT&gt; role2 &lt;ENT&gt; ... }
  :time { tense ... at ... }
  :evid &lt;obs|report|model|sensor|rule&gt;
  :conf &lt;0..1&gt;
)</code></pre>
<p>Surface Gloss:
<code>PRED{args}; TIME[past@...]; EVID[...]; CONF=...;</code></p>
<p>Example: - English: <em>“The cat sleeps on the sofa.”</em> - UL:</p>
<pre><code>(assert
  :event e1
  :pred sleep
  :args { theme (REF cat-1) location (REF sofa-1) }
  :time { tense present }
  :evid obs
  :conf 1.0
)</code></pre>
<p>Gloss:
<code>sleep{theme:cat-1, location:sofa-1}; TIME[present]; EVID[</code><code>obs]; CONF=1.0;</code></p>
<h3 id="request-imperative">8.3 Request (Imperative)</h3>
<p>Pattern:</p>
<pre><code>(request
  :event &lt;id&gt;
  :pred &lt;REL&gt;
  :args { role1 &lt;ENT&gt; ... }
  :constraints {...}
  :by &lt;deadline&gt;
)</code></pre>
<p>Example: - English: <em>“Send me the file by tomorrow.”</em> -
UL:</p>
<pre><code>(request
  :event r1
  :pred send
  :args { agent (REF you) theme (REF file-7) recipient (REF me) }
  :by 2025-09-29T00:00:00Z
  :conf 1.0
)</code></pre>
<h3 id="measurement">8.4 Measurement</h3>
<p>Pattern:</p>
<pre><code>(measure
  :event &lt;id&gt;
  :pred &lt;REL&gt;
  :args { theme &lt;ENT&gt; }
  :value &lt;number&gt;
  :unit &lt;unit&gt;
  :time {...}
  :evid sensor
  :conf &lt;0..1&gt;
)</code></pre>
<p>Example: - English: <em>“The water temperature is 21.3°C.”</em> -
UL:</p>
<pre><code>(measure
  :event m1
  :pred temperature
  :args { theme (REF water-tank-1) }
  :value 21.3
  :unit celsius
  :time { tense present at 2025-09-28T10:00:00Z }
  :evid sensor
  :conf 0.98
)</code></pre>
<h3 id="comparison">8.5 Comparison</h3>
<p>Pattern:</p>
<pre><code>(compare
  :event &lt;id&gt;
  :pred &lt;REL&gt;
  :args { theme1 &lt;ENT&gt; theme2 &lt;ENT&gt; }
  :relation &lt;equal|greater|less&gt;
)</code></pre>
<p>Example: - English: <em>“Alice is taller than Bob.”</em> - UL:</p>
<pre><code>(compare
  :event c1
  :pred height
  :args { theme1 (REF alice) theme2 (REF bob) }
  :relation greater
  :conf 0.9
)</code></pre>
<h3 id="repair">8.6 Repair</h3>
<p>Pattern:</p>
<pre><code>(repair
  :on &lt;event-id&gt;
  :need &lt;missing-field&gt;
)</code></pre>
<p>Example: - English: <em>“What unit?”</em> - UL:</p>
<pre><code>(repair
  :on m1
  :need unit
)</code></pre>
<h3 id="exercises">8.7 Exercises</h3>
<p>Translate into UL: 1. <em>“The dog barked yesterday.”</em> 2.
<em>“Please open the window.”</em> 3. <em>“The weight is 12
kilograms.”</em> 4. <em>“Is Paris larger than Lyon?”</em></p>
<h1 id="chapter-9.-expressing-time-modality">Chapter 9. Expressing Time
&amp; Modality</h1>
<h3 id="time">9.1 Time</h3>
<p>UL always encodes <strong>when</strong> something happens. - Tense:
past, present, future. - Specific timestamp: ISO 8601. - Interval:
start–end.</p>
<p>Examples: - <em>“Yesterday”</em> →
<code>:time { tense past at 2025-09-27 }</code> - <em>“From 9 to 10
am”</em> → <code>:time { interval { start 09:00 end 10:00 } }</code></p>
<h3 id="aspect">9.2 Aspect</h3>
<p>UL can express ongoing or completed states: - <em>progressive</em> =
still happening. - <em>perfect</em> = completed.</p>
<p>Example: <em>“Alice has eaten”</em> →</p>
<pre><code>(assert
  :event e2
  :pred eat
  :args { agent (REF alice) theme (REF cake-1) }
  :time { tense past aspect perfect }
  :evid report
  :conf 0.95
)</code></pre>
<h3 id="modality-1">9.3 Modality</h3>
<p>UL separates types of modality: - <strong>Epistemic</strong> =
likelihood (<em>likely, possible</em>). - <strong>Deontic</strong> =
rules/obligations (<em>must, may</em>). - <strong>Ability</strong> =
capacity (<em>can</em>).</p>
<p>Example: - English: <em>“Alice must leave.”</em> - UL:</p>
<pre><code>(assert
  :event e3
  :pred leave
  :args { agent (REF alice) }
  :time { tense future }
  :mod { type deontic val must }
  :evid rule
  :conf 1.0
)</code></pre>
<h3 id="combining-time-modality">9.4 Combining Time &amp; Modality</h3>
<ul>
<li><em>“Alice might have left yesterday.”</em></li>
</ul>
<pre><code>(assert
  :event e4
  :pred leave
  :args { agent (REF alice) }
  :time { tense past at 2025-09-27 }
  :mod { type epistemic val possible }
  :evid report
  :conf 0.6
)</code></pre>
<h3 id="exercises-1">9.5 Exercises</h3>
<ol type="1">
<li>Translate <em>“Bob will probably arrive tomorrow.”</em></li>
<li>Translate <em>“You may enter at 10:00.”</em></li>
</ol>
<h1 id="chapter-10.-quantifiers-negation">Chapter 10. Quantifiers &amp;
Negation</h1>
<h3 id="quantifiers">10.1 Quantifiers</h3>
<p>UL expresses quantifiers with explicit scope. - <em>“All dogs
bark.”</em></p>
<pre><code>(assert
  :event e5
  :pred bark
  :args { theme (forall x (dog x)) }
  :conf 0.9
)</code></pre>
<ul>
<li><em>“Some dogs bark.”</em></li>
</ul>
<pre><code>(assert
  :event e6
  :pred bark
  :args { theme (exists x (dog x)) }
  :conf 0.9
)</code></pre>
<h3 id="negation-1">10.2 Negation</h3>
<p>Negation is explicit and scoped. - <em>“The cat is not
sleeping.”</em></p>
<pre><code>(assert
  :event e7
  :pred sleep
  :args { theme (REF cat-1) }
  :time { tense present }
  :neg true
  :conf 1.0
)</code></pre>
<ul>
<li><em>“Not all dogs bark.”</em></li>
</ul>
<pre><code>(assert
  :event e8
  :pred bark
  :args { theme (forall x (dog x)) }
  :neg true
  :scope dogs
  :conf 0.95
)</code></pre>
<h3 id="exercises-2">10.3 Exercises</h3>
<ol type="1">
<li>Encode <em>“Some students did not attend.”</em></li>
<li>Encode <em>“All birds cannot swim.”</em></li>
</ol>
<h1 id="chapter-11.-evidence-confidence">Chapter 11. Evidence &amp;
Confidence</h1>
<h3 id="evidence-types">11.1 Evidence Types</h3>
<p>Every statement must specify <strong>source</strong>: -
<code>obs</code> = direct human observation. - <code>sensor</code> =
device measurement. - <code>report</code> = second-hand info. -
<code>model</code> = simulation, forecast. - <code>rule</code> = law,
axiom, definition.</p>
<h3 id="confidence-1">11.2 Confidence</h3>
<p>Numeric probability from 0.0 to 1.0. - 1.0 = certain. - 0.5 =
uncertain. - 0.0 = impossible.</p>
<h3 id="combined-example">11.3 Combined Example</h3>
<p><em>“It will probably rain tomorrow (weather model).”</em></p>
<pre><code>(assert
  :event e9
  :pred rain
  :args { location (REF paris) }
  :time { tense future at 2025-09-29 }
  :mod { type epistemic val likely }
  :evid model
  :conf 0.7
)</code></pre>
<h3 id="exercises-3">11.4 Exercises</h3>
<ol type="1">
<li>Encode <em>“Apparently, Alice is in Berlin.”</em></li>
<li>Encode <em>“The sensor shows 35.1°C with 98% certainty.”</em></li>
</ol>
<h1 id="chapter-12.-complex-structures">Chapter 12. Complex
Structures</h1>
<h3 id="recursion">12.1 Recursion</h3>
<p>UL allows nested clauses. <em>“The man who saw the woman who had a
dog smiled.”</em></p>
<pre><code>(assert
  :event e10
  :pred smile
  :args {
    agent (REF man-1)
    cause (assert
      :event e11
      :pred see
      :args {
        agent (REF man-1)
        theme (REF woman-1)
      }
      :sub (assert
        :event e12
        :pred have
        :args { agent (REF woman-1) theme (REF dog-1) }
      )
    )
  }
)</code></pre>
<h3 id="conditionals">12.2 Conditionals</h3>
<p><em>“If it rains, the game will be canceled.”</em></p>
<pre><code>(assert
  :event e13
  :pred cancel
  :args { theme (REF game-1) }
  :time { tense future }
  :cond (assert
    :event e14
    :pred rain
    :time { tense future }
  )
)</code></pre>
<h3 id="constraints">12.3 Constraints</h3>
<p><em>“Send the file (must be &lt;50MB, format CSV).”</em></p>
<pre><code>(request
  :event r2
  :pred send
  :args { agent (REF you) theme (REF file-9) }
  :constraints { size &lt; 50MB; format csv }
)</code></pre>
<h3 id="exercises-4">12.4 Exercises</h3>
<ol type="1">
<li>Encode <em>“If Alice comes, Bob will leave.”</em></li>
<li>Encode <em>“Every student who passed the exam received a
certificate.”</em></li>
</ol>
<h1 id="chapter-13.-exercises-drills">Chapter 13. Exercises &amp;
Drills</h1>
<h3 id="beginner">13.1 Beginner</h3>
<ol type="1">
<li><em>“The lamp is on.”</em></li>
<li><em>“Please close the door.”</em></li>
<li><em>“The weight is 10kg.”</em></li>
</ol>
<h3 id="intermediate">13.2 Intermediate</h3>
<ol type="1">
<li><em>“Alice might be in Paris.”</em></li>
<li><em>“Not all cats like milk.”</em></li>
<li><em>“Send the report by tomorrow.”</em></li>
</ol>
<h3 id="advanced">13.3 Advanced</h3>
<ol type="1">
<li><em>“If Bob doesn’t study, he will fail.”</em></li>
<li><em>“Every researcher who wrote a paper received funding.”</em></li>
<li><em>“It will probably snow next week, according to the
forecast.”</em></li>
</ol>
<h3 id="answer-key-selected">13.4 Answer Key (selected)</h3>
<ol type="1">
<li><em>“The lamp is on.”</em></li>
</ol>
<pre><code>(assert
  :event e15
  :pred on
  :args { theme (REF lamp-1) }
  :time { tense present }
  :evid obs
  :conf 1.0
)</code></pre>
<ol start="2" type="1">
<li><em>“Alice might be in Paris.”</em></li>
</ol>
<pre><code>(assert
  :event e16
  :pred located_in
  :args { theme (REF alice) location (REF paris) }
  :mod { type epistemic val possible }
  :evid report
  :conf 0.6
)</code></pre>
<hr />
<h2 id="part-iii-encyclopedic-lexicon">Part III – Encyclopedic
Lexicon</h2>
<h1 id="chapter-14.-core-predicate-lexicon">Chapter 14. Core Predicate
Lexicon</h1>
<h3 id="purpose">14.1 Purpose</h3>
<p>Predicates are the <strong>action words</strong> of UL. They define
what kind of relation is being asserted, requested, or measured. Unlike
natural languages, UL predicates are: - <strong>Regular</strong> — no
irregular verbs. - <strong>Frame-based</strong> — each predicate comes
with a fixed set of roles. - <strong>Expandable</strong> — new domains
can add their own namespaces (e.g., <code>bio:binds_to</code>).</p>
<h3 id="starter-predicate-set">14.2 Starter Predicate Set</h3>
<p><strong>Existence &amp; Identity</strong> - <code>be</code> (state,
property, identity) - <code>equal</code> (two entities are identical) -
<code>exist</code> (entity exists)</p>
<p><strong>Possession &amp; Transfer</strong> - <code>have</code>
(possession) - <code>own</code> (ownership) - <code>give</code>
(transfer ownership)</p>
<p><strong>Action &amp; Process</strong> - <code>do</code> (generic
action) - <code>move</code> (agent moves theme to location) -
<code>make</code> (agent creates theme)</p>
<p><strong>Perception &amp; Communication</strong> - <code>see</code>
(perceive visually) - <code>hear</code> (perceive auditorily) -
<code>say</code> (agent communicates theme to recipient) -
<code>ask</code> (agent requests info from recipient)</p>
<p><strong>Measurement &amp; Comparison</strong> - <code>measure</code>
(report quantitative value) - <code>compare</code> (evaluate relation:
equal, greater, less)</p>
<p><strong>Causality &amp; Permission</strong> - <code>cause</code>
(agent causes event) - <code>allow</code> (agent permits event) -
<code>require</code> (obligation, necessity)</p>
<p><strong>Spatial Relations</strong> - <code>located_in</code> (entity
at place) - <code>part_of</code> (entity is part of whole)</p>
<h3 id="example">14.3 Example</h3>
<pre><code>(assert
  :event e20
  :pred give
  :args { agent (REF alice) theme (REF book-1) recipient (REF bob) }
  :time { tense past }
  :evid report
  :conf 0.95
)</code></pre>
<p>Gloss:
<code>give{agent:Alice, theme:book-1, recipient:Bob}; TIME[past]; EVID[report]; CONF=0.95;</code></p>
<h3 id="expansion">14.4 Expansion</h3>
<p>Specialized fields (medicine, law, engineering) can define new
predicates under namespaces: - <code>med:diagnose</code>,
<code>med:prescribe</code> - <code>law:contract_signed</code> -
<code>eng:voltage</code></p>
<p>All must follow the <strong>frame principle</strong>: clear predicate
+ fixed roles.</p>
<h1 id="chapter-15.-role-inventory">Chapter 15. Role Inventory</h1>
<h3 id="purpose-1">15.1 Purpose</h3>
<p>Roles connect predicates to entities. Each predicate declares which
roles it expects. Roles prevent ambiguity: instead of “Bob saw Alice
with a telescope,” UL clarifies <strong>who had the
telescope</strong>.</p>
<h3 id="core-roles">15.2 Core Roles</h3>
<ul>
<li><strong>agent</strong> — the doer (subject in many languages).</li>
<li><strong>theme/patient</strong> — the entity acted upon.</li>
<li><strong>recipient</strong> — entity receiving something.</li>
<li><strong>source</strong> — origin of motion/transfer.</li>
<li><strong>goal</strong> — target or destination.</li>
<li><strong>location</strong> — place.</li>
<li><strong>instrument</strong> — tool used.</li>
<li><strong>cause</strong> — event or condition triggering
something.</li>
<li><strong>beneficiary</strong> — entity that benefits.</li>
<li><strong>experiencer</strong> — entity perceiving or feeling.</li>
</ul>
<h3 id="example-1">15.3 Example</h3>
<p><em>“Alice cut the bread with a knife.”</em></p>
<pre><code>(assert
  :event e21
  :pred cut
  :args { agent (REF alice) theme (REF bread-1) instrument (REF knife-1) }
  :time { tense past }
  :evid obs
  :conf 1.0
)</code></pre>
<h3 id="benefits">15.4 Benefits</h3>
<ul>
<li>Explicit role labeling → no ambiguity.</li>
<li>Cross-linguistic neutrality → doesn’t depend on subject/object word
order.</li>
<li>Extensible for domain-specific roles (e.g.,
<code>legal:plaintiff</code>, <code>legal:defendant</code>).</li>
</ul>
<h1 id="chapter-16.-modality-evidentiality-tables">Chapter 16. Modality
&amp; Evidentiality Tables</h1>
<h3 id="modality-values">16.1 Modality Values</h3>
<p>UL distinguishes modality <strong>types</strong> and
<strong>values</strong>.</p>
<p><strong>Epistemic (belief/knowledge):</strong> - <code>certain</code>
(conf=1.0) - <code>likely</code> - <code>possible</code> -
<code>unlikely</code></p>
<p><strong>Deontic (rules/obligations):</strong> - <code>must</code> -
<code>may</code> - <code>forbidden</code></p>
<p><strong>Ability/Capacity:</strong> - <code>can</code> -
<code>cannot</code></p>
<h3 id="evidentiality-1">16.2 Evidentiality</h3>
<p>Specifies <strong>source of information</strong>. - <code>obs</code>
= direct human observation. - <code>sensor</code> = device measurement.
- <code>report</code> = second-hand information. - <code>model</code> =
simulation or forecast. - <code>rule</code> = deduction from law or
axiom.</p>
<h3 id="examples-1">16.3 Examples</h3>
<p><em>“Alice must leave (by rule).”</em></p>
<pre><code>(assert
  :event e22
  :pred leave
  :args { agent (REF alice) }
  :time { tense future }
  :mod { type deontic val must }
  :evid rule
  :conf 1.0
)</code></pre>
<p><em>“It will probably rain (weather model).”</em></p>
<pre><code>(assert
  :event e23
  :pred rain
  :args { location (REF berlin) }
  :time { tense future at 2025-09-29 }
  :mod { type epistemic val likely }
  :evid model
  :conf 0.7
)</code></pre>
<h1 id="chapter-17.-units-measures">Chapter 17. Units &amp;
Measures</h1>
<h3 id="necessity">17.1 Necessity</h3>
<p>Numbers without units are meaningless. Natural language often omits
them (<em>“It weighs 10”</em>). UL enforces <strong>mandatory
units</strong>.</p>
<h3 id="si-units">17.2 SI Units</h3>
<p>Base set: - Length: meter (m) - Mass: kilogram (kg) - Time: second
(s) - Temperature: kelvin (K), celsius (°C) - Electric current: ampere
(A) - Substance: mole (mol) - Luminous intensity: candela (cd)</p>
<h3 id="derived-units">17.3 Derived Units</h3>
<ul>
<li>Velocity: m/s</li>
<li>Area: m²</li>
<li>Volume: m³</li>
<li>Energy: joule (J)</li>
<li>Power: watt (W)</li>
</ul>
<h3 id="example-2">17.4 Example</h3>
<p><em>“The mass is 12 kilograms.”</em></p>
<pre><code>(measure
  :event m2
  :pred mass
  :args { theme (REF sample-1) }
  :value 12
  :unit kg
  :evid sensor
  :conf 1.0
)</code></pre>
<h3 id="extensibility">17.5 Extensibility</h3>
<p>Domains can add custom units: - Finance: <code>USD</code>,
<code>EUR</code>, <code>%</code> - Medicine: <code>mg/dL</code>,
<code>mmHg</code> - Computing: <code>MB</code>, <code>GB</code>,
<code>ms</code></p>
<h1 id="chapter-18.-ontology-expansion-guide">Chapter 18. Ontology
Expansion Guide</h1>
<h3 id="why-expansion">18.1 Why Expansion?</h3>
<p>The core lexicon is small but must scale. New fields need new terms —
but expansion must remain <strong>structured</strong>.</p>
<h3 id="namespaces">18.2 Namespaces</h3>
<p>UL adopts the namespace model: - <code>geo:</code> for geography. -
<code>med:</code> for medicine. - <code>law:</code> for law. -
<code>eng:</code> for engineering.</p>
<p>Predicates are prefixed by namespace: - <code>med:diagnose</code> -
<code>law:contract_signed</code></p>
<h3 id="linking-to-external-ontologies">18.3 Linking to External
Ontologies</h3>
<p>UL allows every predicate or entity to carry a <code>:link</code> to
an external ontology. Example:</p>
<pre><code>(assert
  :event e24
  :pred med:diagnose
  :args { agent (REF doctor-1) theme (REF patient-1) condition (REF diabetes) }
  :link https://www.wikidata.org/entity/Q1220
  :time { tense past }
  :evid report
  :conf 0.95
)</code></pre>
<h3 id="best-practices">18.4 Best Practices</h3>
<ol type="1">
<li>Use short, stable namespaces.</li>
<li>Always attach external links where available.</li>
<li>Maintain domain dictionaries for consistency.</li>
<li>Avoid synonym duplication — one predicate per concept.</li>
</ol>
<hr />
<h2 id="part-iv-reference-interoperability">Part IV – Reference &amp;
Interoperability</h2>
<h1 id="chapter-19.-serialization-formats">Chapter 19. Serialization
Formats</h1>
<h3 id="why-multiple-formats">19.1 Why Multiple Formats?</h3>
<p>Different systems require different encodings. UL supports: -
<strong>S-expressions</strong> — default, human-readable. -
<strong>JSON</strong> — widely supported in APIs. -
<strong>CBOR</strong> — binary, compact for networks.</p>
<h3 id="example-s-expr">19.2 Example (S-expr)</h3>
<pre><code>(assert
  :event e25
  :pred own
  :args { agent (REF alice) theme (REF car-17) }
  :time { tense present }
  :conf 1.0
)</code></pre>
<h3 id="example-json">19.3 Example (JSON)</h3>
<pre><code>{
  &quot;event&quot;: &quot;e25&quot;,
  &quot;pred&quot;: &quot;own&quot;,
  &quot;args&quot;: { &quot;agent&quot;: &quot;alice&quot;, &quot;theme&quot;: &quot;car-17&quot; },
  &quot;time&quot;: { &quot;tense&quot;: &quot;present&quot; },
  &quot;conf&quot;: 1.0
}</code></pre>
<h3 id="example-cbor">19.4 Example (CBOR)</h3>
<p>Binary compact representation — efficient for IoT devices.</p>
<h3 id="integrity">19.5 Integrity</h3>
<p>All messages may include a <code>:sig</code> field with SHA-256 hash
or digital signature for verification.</p>
<h1 id="chapter-20.-error-handling-repair-protocols">Chapter 20. Error
Handling &amp; Repair Protocols</h1>
<h3 id="repair-principle">20.1 Repair Principle</h3>
<p>In natural conversation, misunderstandings trigger repair
(<em>“What?”</em>). UL formalizes this: - <strong>repair</strong> =
request missing info. - <strong>fail</strong> = report task not
completed.</p>
<h3 id="repair-example">20.2 Repair Example</h3>
<pre><code>(repair
  :on m2
  :need unit
)</code></pre>
<h3 id="fail-example">20.3 Fail Example</h3>
<pre><code>(fail
  :of r2
  :reason size_limit_exceeded
)</code></pre>
<h3 id="benefits-1">20.4 Benefits</h3>
<ul>
<li>Keeps conversation alive.</li>
<li>Ensures graceful failure, not silent collapse.</li>
<li>Machine + human interpretable.</li>
</ul>
<h1 id="chapter-21.-transport-compression">Chapter 21. Transport &amp;
Compression</h1>
<h3 id="transport-agnosticism">21.1 Transport Agnosticism</h3>
<p>UL messages can move over: - HTTP/HTTPS - MQTT (IoT) - Email/SMTP -
P2P protocols</p>
<h3 id="compression">21.2 Compression</h3>
<p>Because UL is structured with repeated tags, gzip/CBOR compression
achieves high reduction in size.</p>
<h3 id="streaming">21.3 Streaming</h3>
<p>Messages can be chunked and streamed with envelope headers
preserved.</p>
<h1 id="chapter-22.-mapping-to-natural-languages">Chapter 22. Mapping to
Natural Languages</h1>
<h3 id="english">22.1 English</h3>
<p>Direct mapping with surface gloss.</p>
<p><em>“Alice owns a car.”</em> →
<code>own{agent:Alice, theme:car-1}; TIME[present]; CONF=1.0;</code></p>
<h3 id="german">22.2 German</h3>
<p><em>“Alice besitzt ein Auto.”</em> → same UL core.</p>
<h3 id="mandarin">22.3 Mandarin</h3>
<p><em>“Alice 有一辆车。”</em> → same UL.</p>
<h3 id="signed-languages">22.4 Signed Languages</h3>
<p>Roles map directly: agent, theme, location, etc. Surface gloss can be
signed with fixed handshapes.</p>
<h1 id="chapter-23.-humanai-communication-scenarios">Chapter 23.
Human–AI Communication Scenarios</h1>
<h3 id="dialogue">23.1 Dialogue</h3>
<p>Human: <em>“Please send the file.”</em> AI:</p>
<pre><code>(request
  :event r3
  :pred send
  :args { agent (REF human-1) theme (REF file-1) recipient (REF ai-1) }
)</code></pre>
<h3 id="negotiation">23.2 Negotiation</h3>
<p>Human: <em>“By tomorrow?”</em> AI:</p>
<pre><code>(repair
  :on r3
  :need deadline
)</code></pre>
<h3 id="confirmation">23.3 Confirmation</h3>
<p>Human: <em>“Yes, by tomorrow.”</em> AI updates request with
deadline.</p>
<h1 id="chapter-24.-aiai-protocol-examples">Chapter 24. AI–AI Protocol
Examples</h1>
<h3 id="sensor-network">24.1 Sensor Network</h3>
<p>Sensor → Hub:</p>
<pre><code>(measure
  :event m3
  :pred temperature
  :args { theme (REF greenhouse-1) }
  :value 18.7
  :unit celsius
  :time { tense present at 2025-09-28T11:00:00Z }
  :evid sensor
  :conf 0.99
)</code></pre>
<h3 id="multi-agent-planning">24.2 Multi-Agent Planning</h3>
<p>Agent A → Agent B:</p>
<pre><code>(request
  :event r4
  :pred fetch
  :args { theme (LINK https://example.org/data.csv) }
  :constraints { format csv size &lt; 10MB }
  :by 2025-09-29T12:00:00Z
)</code></pre>
<h3 id="distributed-knowledge-graph">24.3 Distributed Knowledge
Graph</h3>
<p>Agent C asserts new knowledge:</p>
<pre><code>(assert
  :event e26
  :pred located_in
  :args { theme (REF factory-7) location (REF berlin) }
  :time { tense present }
  :evid report
  :conf 0.85
)</code></pre>
<hr />
<h2 id="part-v-appendices">Part V – Appendices</h2>
<h1 id="appendix-a.-formal-grammar-ebnf-json-schema">Appendix A. Formal
Grammar (EBNF + JSON Schema)</h1>
<h2 id="ebnf-expanded">EBNF (expanded)</h2>
<pre><code>ul-message  = envelope nl core ;
envelope    = &quot;UL/1&quot; nl &quot;id:&quot; uuid nl &quot;from:&quot; agent nl &quot;to:&quot; agent-list nl &quot;t:&quot; iso8601 [ nl &quot;ctx:&quot; token ] [ nl &quot;sig:&quot; token ] ;
core        = { statement } ;
statement   = assert | request | measure | compare | repair | fail ;

assert      = &quot;(&quot; &quot;assert&quot; kvpairs &quot;)&quot; ;
request     = &quot;(&quot; &quot;request&quot; kvpairs &quot;)&quot; ;
measure     = &quot;(&quot; &quot;measure&quot; kvpairs &quot;)&quot; ;
compare     = &quot;(&quot; &quot;compare&quot; kvpairs &quot;)&quot; ;
repair      = &quot;(&quot; &quot;repair&quot; kvpairs &quot;)&quot; ;
fail        = &quot;(&quot; &quot;fail&quot; kvpairs &quot;)&quot; ;

kvpairs     = { kvpair } ;
kvpair      = &quot;:&quot; key value ;
value       = symbol | number | string | sexpr | dict ;
sexpr       = &quot;(&quot; symbol { kvpair } &quot;)&quot; ;
dict        = &quot;{&quot; { key value } &quot;}&quot; ;

time        = &quot;{&quot; &quot;tense&quot; tense [ &quot;at&quot; timespec | &quot;interval&quot; &quot;{&quot; &quot;start&quot; timespec &quot;end&quot; timespec &quot;}&quot; ] [ &quot;aspect&quot; aspect ] &quot;}&quot; ;
tense       = &quot;past&quot; | &quot;present&quot; | &quot;future&quot; ;
aspect      = &quot;progressive&quot; | &quot;perfect&quot; ;
mod-type    = &quot;epistemic&quot; | &quot;deontic&quot; | &quot;ability&quot; ;
mod-val     = &quot;must&quot; | &quot;may&quot; | &quot;can&quot; | &quot;likely&quot; | &quot;possible&quot; | &quot;necessary&quot; | &quot;unlikely&quot; ;

role        = &quot;agent&quot; | &quot;theme&quot; | &quot;patient&quot; | &quot;recipient&quot; | &quot;source&quot; | &quot;goal&quot; | &quot;location&quot; | &quot;instrument&quot; | &quot;beneficiary&quot; | &quot;cause&quot; | &quot;experiencer&quot; ;
evid        = &quot;obs&quot; | &quot;sensor&quot; | &quot;report&quot; | &quot;model&quot; | &quot;rule&quot; ;
relation    = &quot;equal&quot; | &quot;greater&quot; | &quot;less&quot; ;

symbol      = /[A-Za-z_][A-Za-z0-9_-]*/ ;
uuid        = /[A-Fa-f0-9-]{8,}/ ;
iso8601     = /[0-9TZ:+-]{10,}/ ;
key         = symbol ;
token       = /[^\s]+/ ;
number      = /-?[0-9]+(\.[0-9]+)?/ ;
string      = /&quot;[^&quot;]*&quot;/ ;</code></pre>
<h2 id="json-schema-core-object">JSON Schema (core object)</h2>
<pre><code>{
  &quot;$schema&quot;: &quot;https://json-schema.org/draft/2020-12/schema&quot;,
  &quot;title&quot;: &quot;UL Core Statement&quot;,
  &quot;type&quot;: &quot;object&quot;,
  &quot;properties&quot;: {
    &quot;event&quot;: { &quot;type&quot;: &quot;string&quot; },
    &quot;pred&quot;:  { &quot;type&quot;: &quot;string&quot; },
    &quot;args&quot;:  { &quot;type&quot;: &quot;object&quot;, &quot;additionalProperties&quot;: { &quot;type&quot;: [&quot;string&quot;,&quot;number&quot;,&quot;object&quot;,&quot;array&quot;] } },
    &quot;time&quot;:  { &quot;type&quot;: &quot;object&quot; },
    &quot;mod&quot;:   { &quot;type&quot;: &quot;object&quot; },
    &quot;neg&quot;:   { &quot;type&quot;: &quot;boolean&quot; },
    &quot;evid&quot;:  { &quot;type&quot;: &quot;string&quot;, &quot;enum&quot;: [&quot;obs&quot;,&quot;sensor&quot;,&quot;report&quot;,&quot;model&quot;,&quot;rule&quot;] },
    &quot;conf&quot;:  { &quot;type&quot;: &quot;number&quot;, &quot;minimum&quot;: 0.0, &quot;maximum&quot;: 1.0 },
    &quot;unit&quot;:  { &quot;type&quot;: &quot;string&quot; },
    &quot;notes&quot;: { &quot;type&quot;: &quot;string&quot; },
    &quot;link&quot;:  { &quot;type&quot;: [&quot;string&quot;,&quot;null&quot;] }
  },
  &quot;required&quot;: [&quot;event&quot;,&quot;pred&quot;,&quot;args&quot;],
  &quot;additionalProperties&quot;: true
}</code></pre>
<h1 id="appendix-b.-quick-reference-cheat-sheet">Appendix B.
Quick-Reference Cheat Sheet</h1>
<p><strong>Statement Types</strong> - Assertion: <code>(assert …)</code>
- Request: <code>(request …)</code> - Measurement:
<code>(measure …)</code> - Comparison: <code>(compare …)</code> -
Repair: <code>(repair …)</code> - Failure: <code>(fail …)</code></p>
<p><strong>Core Atoms</strong>: ENT, REL, TIME, MOD, NEG, EVID, CONF,
UNIT, REF, LINK, SCOPE.</p>
<p><strong>Core Roles</strong>: agent, theme/patient, recipient, source,
goal, location, instrument, beneficiary, cause, experiencer.</p>
<p><strong>Modality Types</strong>: epistemic, deontic, ability.
<strong>Evidentiality</strong>: obs, sensor, report, model, rule.
<strong>Time</strong>: past, present, future; absolute ISO timestamps or
intervals. <strong>Negation</strong>: <code>:neg true</code> with
explicit <code>:scope</code> when needed.</p>
<h1 id="appendix-c.-worked-examples">Appendix C. Worked Examples</h1>
<p><strong>English → UL → Gloss</strong></p>
<ol type="1">
<li>“Could you probably send me the latest report by tomorrow? It’s
around 5MB.”</li>
</ol>
<pre><code>(request
  :event r12
  :pred send
  :args { agent (REF you) theme (REF report-latest) recipient (REF me) }
  :time { tense future at 2025-09-29T00:00:00Z }
  :mod  { type deontic val request }
  :meta { approx_size 5MB }
  :evid report
  :conf 0.80
)</code></pre>
<p>Gloss:
<code>send{agent:you, theme:report#latest, to:me}; TIME[future@2025-09-29T00:00Z]; MOD[deontic:request]; SIZE[≈5MB]; EVID[report]; CONF=0.8;</code></p>
<ol start="2" type="1">
<li>“Alice is taller than Bob.”</li>
</ol>
<pre><code>(compare
  :event c1
  :pred height
  :args { theme1 (REF alice) theme2 (REF bob) }
  :relation greater
  :conf 0.9
)</code></pre>
<h1 id="appendix-d.-mini-dictionary">Appendix D. Mini-Dictionary</h1>
<p><strong>Predicates (sample)</strong> be, equal, exist, have, own,
give, do, move, make, see, hear, say, ask, measure, compare, cause,
allow, require, located_in, part_of, cut, rain, leave, on.</p>
<p><strong>Roles</strong> agent, theme/patient, recipient, source, goal,
location, instrument, beneficiary, cause, experiencer.</p>
<p><strong>Modality Values</strong> must, may, can, likely, possible,
forbidden, certain, unlikely.</p>
<p><strong>Evidentiality</strong> obs, sensor, report, model, rule.</p>
<p><strong>Units</strong> m, kg, s, °C, J, W, m², m³, m/s, USD, EUR,
mg/dL, mmHg, MB, GB, ms.</p>
<h1 id="appendix-e.-self-study-drills-with-selected-answers">Appendix E.
Self-Study Drills (with Selected Answers)</h1>
<p><strong>Beginner</strong> - The lamp is on. - Please close the door.
- The weight is 10kg.</p>
<p><strong>Intermediate</strong> - Alice might be in Paris. - Not all
cats like milk. - Send the report by tomorrow.</p>
<p><strong>Advanced</strong> - If Bob doesn’t study, he will fail. -
Every researcher who wrote a paper received funding. - It will probably
snow next week, according to the forecast.</p>
<p><strong>Selected Answers</strong> See Chapter 13.4.</p>
<p>© 2025 Patrick A. Gessner · Universal Logos Project</p>
</body>
</html>
